<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bino-Method</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- TensorFlow.js Core -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
  <!-- TensorFlow.js WebGL Backend -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@3.11.0/dist/tf-backend-webgl.min.js"></script>
  <!-- Pose Detection Model -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@0.0.6/dist/pose-detection.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    .video-container { position: relative; width: 100%; padding-bottom: 56.25%; /* 16:9 */ }
    .video-container video { display: none !important; }
    .video-container canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
    .alert-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #f87171; background: rgba(0,0,0,0.6); padding: 1rem; border-radius: 0.5rem; font-size: 1.2rem; display: none; }
  </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
  <div class="container mx-auto p-4">
    <header class="text-center mb-6">
      <h1 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500">Bino-Bod-Mapper</h1>
    </header>

    <div class="grid lg:grid-cols-3 gap-6">
      <!-- Video & Controls -->
      <div class="lg:col-span-2 relative">
        <div class="video-container rounded-lg shadow-lg bg-gray-800">
          <video id="video" playsinline muted></video>
          <canvas id="canvas"></canvas>
        </div>
        <div id="cameraError" class="alert-overlay">Unable to access camera.<br/>Please allow camera or test in a secure context.</div>
        <div class="flex justify-center gap-4 mt-4">
          <select id="modeSelect" class="px-4 py-2 bg-gray-700 rounded">
            <option value="Standing">Standing</option>
            <option value="Walking">Walking</option>
            <option value="Running">Running</option>
            <option value="Squat">Squat</option>
          </select>
          <button id="startBtn" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded">Start</button>
          <button id="stopBtn" class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded" disabled>Stop</button>
        </div>
      </div>

      <!-- Metrics Panel -->
      <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h2 class="font-semibold text-xl mb-2 border-b border-gray-700 pb-2">Posture Metrics</h2>
        <div class="space-y-4">
          <div id="postureStatus" class="flex items-center p-2 bg-gray-700 rounded">
            <div id="statusDot" class="w-3 h-3 bg-gray-500 rounded-full mr-2"></div>
            <span class="font-medium">Status:</span>
            <span id="statusText" class="ml-1">Waiting</span>
          </div>
          <div id="metricsGrid" class="grid grid-cols-2 gap-2">
            <!-- Dynamic metric cards -->
          </div>
          <div>
            <h3 class="font-medium">Alerts</h3>
            <div id="alertsContainer" class="italic text-gray-400">None</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const modeSelect = document.getElementById('modeSelect');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const cameraError = document.getElementById('cameraError');
      const statusDot = document.getElementById('statusDot');
      const statusText = document.getElementById('statusText');
      const metricsGrid = document.getElementById('metricsGrid');
      const alertsEl = document.getElementById('alertsContainer');

      let detector, stream;
      let detecting = false;
      let lastCheck = 0;
      let alerts = [];
      const PAIRS = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);

      // Metric definitions per mode
      const modes = {
        Standing: [
          { id: 'shoulderTilt', label: 'Shoulder Tilt', unit: '°', threshold: 5 },
          { id: 'spineSym', label: 'Spine Symmetry', unit: '%', threshold: 10 },
          { id: 'headOffset', label: 'Head Offset', unit: 'px', thresholdPerc: 0.1 },
          { id: 'pelvicTilt', label: 'Pelvic Tilt', unit: '°', threshold: 5 }
        ],
        Walking: [
          { id: 'stepWidth', label: 'Step Width', unit: 'px', thresholdPerc: 0.1 },
          { id: 'ankleHigh', label: 'Ankle Arch', unit: '', threshold: 0 },
          { id: 'kneeTracking', label: 'Knee Valgus', unit: '°', threshold: 5 },
          { id: 'hipLevel', label: 'Hip Drop', unit: 'px', thresholdPerc: 0.05 }
        ],
        Running: [
          { id: 'footStrike', label: 'Foot Placement', unit: 'px', thresholdPerc: 0.05 },
          { id: 'ankleHigh', label: 'Ankle Arch', unit: '', threshold: 0 },
          { id: 'kneeTracking', label: 'Knee Valgus', unit: '°', threshold: 5 },
          { id: 'torsoLean', label: 'Torso Lean', unit: '°', threshold: 10 }
        ],
        Squat: [
          { id: 'stanceWidth', label: 'Stance Width', unit: 'px', thresholdPerc: 0.2 },
          { id: 'ankleHigh', label: 'Ankle Arch', unit: '', threshold: 0 },
          { id: 'kneeTracking', label: 'Knee Valgus', unit: '°', threshold: 5 },
          { id: 'torsoAngle', label: 'Torso Angle', unit: '°', threshold: 10 }
        ]
      };

      // Initialize metrics UI
      function renderMetrics() {
        metricsGrid.innerHTML = '';
        const current = modes[modeSelect.value];
        current.forEach(m => {
          const card = document.createElement('div');
          card.className = 'p-2 bg-gray-700 rounded';
          card.innerHTML = `${m.label}: <span id="${m.id}">--${m.unit}</span>`;
          metricsGrid.appendChild(card);
        });
      }
      modeSelect.addEventListener('change', renderMetrics);
      renderMetrics();

      async function init() {
        await tf.setBackend('webgl');
        await tf.ready();
        detector = await poseDetection.createDetector(
          poseDetection.SupportedModels.MoveNet,
          { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
        );
        statusText.textContent = 'Ready';
        statusDot.classList.replace('bg-gray-500','bg-green-500');
      }

      async function start() {
        if (detecting) return;
        detecting = true;
        startBtn.disabled = true; stopBtn.disabled = false;
        cameraError.style.display = 'none';
        statusText.textContent = 'Detecting...';
        statusDot.classList.replace('bg-green-500','bg-yellow-500');
        try {
          stream = await navigator.mediaDevices.getUserMedia({ video:true });
        } catch(e) {
          cameraError.style.display='block';
          statusText.textContent='Camera denied';
          statusDot.classList.replace('bg-yellow-500','bg-red-500');
          detecting=false; startBtn.disabled=false; stopBtn.disabled=true;
          return;
        }
        video.srcObject = stream;
        await new Promise(res => video.onloadedmetadata = res);
        video.play();
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        detectLoop();
      }

      function stop() {
        detecting = false;
        startBtn.disabled = false; stopBtn.disabled = true;
        statusText.textContent = 'Stopped';
        statusDot.classList.replace('bg-yellow-500','bg-gray-500');
        cameraError.style.display='none';
        if (stream) {
          stream.getTracks().forEach(t=>t.stop());
          stream = null;
        }
        ctx.clearRect(0,0,canvas.width,canvas.height);
        alertsEl.textContent = 'None';
        renderMetrics();
      }

      async function detectLoop() {
        if (!detecting) return;
        const poses = await detector.estimatePoses(video);
        ctx.drawImage(video,0,0);
        const kps = poses[0]?.keypoints;
        if (!kps || kps.length === 0) {
          statusText.textContent = 'No pose detected';
          statusDot.classList.replace('bg-yellow-500','bg-red-500');
          requestAnimationFrame(detectLoop);
          return;
        }
        drawSkeleton(kps);
        analyze(kps);
        requestAnimationFrame(detectLoop);
      }

      function drawSkeleton(kps) {
        ctx.strokeStyle = 'rgba(0,255,0,0.7)'; ctx.lineWidth = 2;
        PAIRS.forEach(([i,j]) => {
          const p1 = kps[i], p2 = kps[j];
          if (p1?.score>0.3 && p2?.score>0.3) {
            ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
          }
        });
        kps.forEach(kp => {
          if (kp.score>0.3) {
            ctx.beginPath(); ctx.arc(kp.x,kp.y,4,0,2*Math.PI); ctx.fillStyle='#FF5722'; ctx.fill();
          }
        });
      }

      function analyze(kps) {
        const mode = modeSelect.value;
        const Ls = kps[5], Rs = kps[6], Lh = kps[11], Rh = kps[12], Ns = kps[0];
        let vals = {};
        if (mode === 'Standing') {
          if (!Ls || !Rs || !Lh || !Rh || !Ns) {
            statusText.textContent = 'Incomplete keypoints';
            statusDot.classList.replace('bg-green-500','bg-red-500');
            return;
          }
          // Shoulder Tilt
          const sa = Math.abs(Math.atan2(Rs.y-Ls.y, Rs.x-Ls.x) * 180/Math.PI);
          vals.shoulderTilt = sa.toFixed(1);
          document.getElementById('shoulderTilt').textContent = `${vals.shoulderTilt}°`;

          // Spine Symmetry
          const lLen = Math.hypot(Lh.x-Ls.x, Lh.y-Ls.y);
          const rLen = Math.hypot(Rh.x-Rs.x, Rh.y-Rs.y);
          const sp = ((Math.abs(lLen-rLen)/Math.max(lLen,rLen))*100).toFixed(1);
          vals.spineSym = sp;
          document.getElementById('spineSym').textContent = `${sp}%`;

          // Head Offset
          const midY = (Ls.y + Rs.y)/2;
          const ho = (Ns.score > 0.5 ? (Ns.y-midY).toFixed(0) : 0);
          vals.headOffset = ho;
          document.getElementById('headOffset').textContent = `${ho}px`;

          // Pelvic Tilt
          const pa = Math.abs(Math.atan2(Rh.y-Lh.y, Rh.x-Lh.x) * 180/Math.PI).toFixed(1);
          vals.pelvicTilt = pa;
          document.getElementById('pelvicTilt').textContent = `${pa}°`;

          statusText.textContent = vals.shoulderTilt <= 5 && sp <= 10 && Math.abs(ho) <= canvas.height*0.1 && pa <= 5 ? 'Good posture' : 'Posture issues';
          statusDot.classList.toggle('bg-green-500', statusText.textContent==='Good posture');
          statusDot.classList.toggle('bg-red-500', statusText.textContent!=='Good posture');

          // Alerts
          alerts = [];
          if (sa > 5) alerts.push(`Shoulder tilt ${sa.toFixed(1)}°`);
          if (parseFloat(sp) > 10) alerts.push(`Spine asymmetry ${sp}%`);
          if (Math.abs(ho) > canvas.height*0.1) alerts.push(`Head offset ${ho}px`);
          if (parseFloat(pa) > 5) alerts.push(`Pelvic tilt ${pa}°`);
          alertsEl.textContent = alerts.length? alerts.join(', ') : 'None';
        }
        // Extend analysis for other modes...
      }

      startBtn.addEventListener('click', start);
      stopBtn.addEventListener('click', stop);
      init();
    });
  </script>
</body>
</html>
